command: docker cp
short: ファイルやフォルダーを、コンテナー間あるいはローカルファイルシステムとの間でコピーします。
long: |-
  `docker cp`は`SRC_PATH`の内容を`DEST_PATH`にコピーします。
  コンテナーのファイルシステムからローカルマシンに、あるいはその逆にローカルシステムからコンテナーにコピーを行います。
  `SRC_PATH`と`DEST_PATH`のどちらかに`-`を指定すると、tar アーカイブを`STDIN`から、あるいは`STDOUT`へストリーム入出力することができます。
  `CONTAINER`は、実行中、停止中のどちらでもかまいません。
  `SRC_PATH`と`DEST_PATH`はファイルまたはディレクトリを指定します。

  `docker cp`コマンドにおいてコンテナーのパスは、コンテナーの`/`（ルート）ディレクトリからの相対パスであるものとします。
  つまり先頭にスラッシュをつけるかどうかは任意ということです。
  例として`compassionate_darwin:/tmp/foo/myfile.txt`と`compassionate_darwin:tmp/foo/myfile.txt`は同一とみなされます。
  ローカルマシンのパスは、絶対パス、相対パスのいずれでも利用できます。
  ローカルマシンの相対パスが指定された場合、`docker cp`コマンドが実行されたカレントなワーキングディレクトリからの相対パスとして解釈されます。

  `cp`コマンドは Unix の`cp -a`コマンドのような動作をします。
  ディレクトリに対しては再帰的なコピーを行い、可能ならパーミッションをそのまま保持します。
  コピー先の所有者は、ユーザーとそのプライマリグループになります。
  たとえばファイルコピー先がコンテナーである場合、そのファイルは root ユーザーの`UID:GID`になります。
  ファイルコピー先がローカルマシンである場合、そのファイルは`docker cp`コマンドを実行したユーザーの`UID:GID`になります。
  ただし`-a`オプションが指定された場合、`docker cp`はファイルの所有者を、コピー元のユーザーとそのプライマリグループとします。
  `-L`オプションが指定された場合、`docker cp`は`SRC_PATH`内のシンボリックリンクをすべてたどります。
  `docker cp`は`DEST_PATH`の親ディレクトリが存在しない場合、そのディレクトリを生成 **しません**。

  パスセパレーター文字を`/`、第 1 引数を`SRC_PATH`、第 2 引数を`DEST_PATH`としたときに、コピー処理は以下のようになります。

  - `SRC_PATH`がファイルのとき
      - `DEST_PATH`が存在しない
          - ファイルが`DEST_PATH`というファイルとして保存されます。
      - `DEST_PATH`が存在せず、最後に`/`が指定されている
          - エラー発生: コピー先は存在している必要があります。
      - `DEST_PATH`が存在し、それがファイルである
          - コピー先は、コピー元のファイル内容によって上書きされます。
      - `DEST_PATH`が存在し、それがディレクトリである
          - ファイルがコピー先ディレクトリにコピーされ、ファイル名には`SRC_PATH`のベース名が用いられます。
  - `SRC_PATH`がディレクトリのとき
      - `DEST_PATH`が存在しない
          - `DEST_PATH` がディレクトリとして生成されます。
            そしてコピー元ディレクトリの **内容** がそのディレクトリにコピーされます。
      - `DEST_PATH`が存在し、それがファイルである
          - エラー発生: ディレクトリをファイルにコピーすることはできません。
      - `DEST_PATH`が存在し、それがディレクトリである
          - `SRC_PATH` が`/.`（**スラッシュ** と **ドット**）で終わっていない場合
              - コピー元ディレクトリがそのディレクトリにコピーされます。
          - `SRC_PATH` が`/.`（**スラッシュ** と **ドット**）で終わっている場合
              - コピー元ディレクトリの **内容** がそのディレクトリにコピーされます。

  このコマンドにおいては`SRC_PATH`と`DEST_PATH`が、上記ルールに従って存在している必要があります。
  `SRC_PATH`がローカルにあるシンボリックリンクである場合、コピーされるのはデフォルトではシンボリックリンクそのものであって、そのリンク先ではありません。
  シンボリックリンクそのものではなくリンク先をコピーしたい場合は`-L`オプションを指定します。

  `CONTAINER`とそのパスとの区切り文字にはコロン（`:`）が使われます。
  またローカルマシン上の`SRC_PATH`や`DEST_PATH`に対してのパスを指定する際に`:`を用いることもできます。
  たとえば`file:name.txt`です。
  ローカルマシン内のパス指定に`:`を用いる場合は、以下のようにして絶対パスか相対パスかを明示する必要があります。

      `/path/to/file:name.txt` または `./file:name.txt`

  システムファイルとして`/proc`、`/sys`、`/dev`、[tmpfs](run.md#mount-tmpfs---tmpfs) 配下にあるリソース類、あるいはユーザーが生成したマウントは、コピーすることはできません。
  もっとも`docker exec`において`tar`を手動で実行して、そういったファイルをコピーすることはできます。
  以下に示す 2 つの例は方法が異なりますが、やっていることは同じです。
  （`SRC_PATH`と`DEST_PATH`はディレクトリであるとします。）

  ```bash
  $ docker exec CONTAINER tar Ccf $(dirname SRC_PATH) - $(basename SRC_PATH) | tar Cxf DEST_PATH -
  ```

  ```bash
  $ tar Ccf $(dirname SRC_PATH) - $(basename SRC_PATH) | docker exec -i CONTAINER tar Cxf DEST_PATH -
  ```

  `SRC_PATH`として`-`を指定すると、`STDIN`からの内容を tar アーカイブとして入力します。
  このコマンドが tar の内容を、コンテナー内のファイルシステムにある`DEST_PATH`へ抽出します。
  この場合、`DEST_PATH`はディレクトリを指定していなければなりません。
  `DEST_PATH`に`-`を指定すると、コピー元の内容を tar アーカイブとして扱い、`STDOUT`に出力します。
usage: "docker cp [オプション] CONTAINER:SRC_PATH DEST_PATH|-\n\tdocker cp [オプション]
  SRC_PATH|- CONTAINER:DEST_PATH"
pname: docker
plink: docker.yaml
options:
- option: archive
  shorthand: a
  value_type: bool
  default_value: "false"
  description: アーカイブモード。（uid/gid 情報をすべてコピーします。）
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
- option: follow-link
  shorthand: L
  value_type: bool
  default_value: "false"
  description: SRC_PATH 内のシンボリックリンクは常にたどります。
  deprecated: false
  experimental: false
  experimentalcli: false
  kubernetes: false
  swarm: false
deprecated: false
experimental: false
experimentalcli: false
kubernetes: false
swarm: false

